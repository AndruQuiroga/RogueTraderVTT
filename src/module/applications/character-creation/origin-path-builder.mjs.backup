/**
 * Origin Path Visual Builder
 * Interactive flowchart for Rogue Trader character creation using drag-and-drop.
 * Allows players to visually build their character's lifepath through six steps:
 * Home World → Birthright → Lure → Trials → Motivation → Career
 */

import ConfirmationDialog from "../dialogs/confirmation-dialog.mjs";

const { ApplicationV2, HandlebarsApplicationMixin } = foundry.applications.api;

export default class OriginPathBuilder extends HandlebarsApplicationMixin(ApplicationV2) {
    
    /** @override */
    static DEFAULT_OPTIONS = {
        id: "origin-path-builder-{id}",
        classes: ["rogue-trader", "origin-path-builder"],
        tag: "form",
        window: {
            title: "RT.OriginPath.BuilderTitle",
            icon: "fa-solid fa-route",
            minimizable: true,
            resizable: true
        },
        position: {
            width: 900,
            height: 700
        },
        actions: {
            clearSlot: OriginPathBuilder.#clearSlot,
            randomize: OriginPathBuilder.#randomize,
            reset: OriginPathBuilder.#reset,
            export: OriginPathBuilder.#export,
            import: OriginPathBuilder.#import,
            openCompendium: OriginPathBuilder.#openCompendium,
            viewItem: OriginPathBuilder.#viewItem,
            commitPath: OriginPathBuilder.#commitPath
        },
        dragDrop: [{ dragSelector: ".origin-step-slot", dropSelector: ".origin-step-slot" }],
        form: {
            handler: OriginPathBuilder.#onFormSubmit,
            submitOnChange: false
        }
    };

    /** @override */
    static PARTS = {
        form: {
            template: "systems/rogue-trader/templates/character-creation/origin-path-builder.hbs",
            scrollable: [".path-canvas"]
        }
    };

    /* -------------------------------------------- */

    /**
     * Origin path step configuration
     * @type {Array<{key: string, label: string, step: string, icon: string}>}
     */
    static STEPS = [
        { key: "homeWorld", label: "RT.OriginPath.HomeWorld", step: "Home World", icon: "fa-globe" },
        { key: "birthright", label: "RT.OriginPath.Birthright", step: "Birthright", icon: "fa-baby" },
        { key: "lureOfTheVoid", label: "RT.OriginPath.LureOfTheVoid", step: "Lure of the Void", icon: "fa-rocket" },
        { key: "trialsAndTravails", label: "RT.OriginPath.TrialsAndTravails", step: "Trials and Travails", icon: "fa-skull" },
        { key: "motivation", label: "RT.OriginPath.Motivation", step: "Motivation", icon: "fa-heart" },
        { key: "career", label: "RT.OriginPath.Career", step: "Career", icon: "fa-briefcase" }
    ];

    /* -------------------------------------------- */

    /**
     * @param {Actor} actor - The character actor
     * @param {object} [options={}] - Additional options
     */
    constructor(actor, options = {}) {
        super(options);
        
        /**
         * The character actor being built
         * @type {Actor}
         */
        this.actor = actor;

        /**
         * Current selections for each step (itemId or null)
         * @type {Object<string, string|null>}
         */
        this.selections = {};

        /**
         * Cached item data for each step
         * @type {Object<string, object|null>}
         */
        this.itemCache = {};

        // Initialize selections from actor's existing items
        this._initializeFromActor();
    }

    /* -------------------------------------------- */

    /**
     * The unique identifier for this builder instance
     * @type {string}
     */
    get id() {
        return `origin-path-builder-${this.actor.id}`;
    }

    /** @override */
    get title() {
        return game.i18n.format("RT.OriginPath.BuilderTitle", { name: this.actor.name });
    }

    /* -------------------------------------------- */

    /**
     * Initialize selections from actor's existing origin path items
     * @private
     */
    _initializeFromActor() {
        const originItems = this.actor.items.filter(i => i.isOriginPath);
        
        for (const item of originItems) {
            const step = item.originPathStep;
            const stepKey = this._getStepKeyFromLabel(step);
            
            if (stepKey) {
                this.selections[stepKey] = item.id;
                this.itemCache[stepKey] = item;
            }
        }
    }

    /**
     * Convert step label to step key
     * @param {string} label - Step label (e.g., "Home World")
     * @returns {string|null} Step key (e.g., "homeWorld")
     * @private
     */
    _getStepKeyFromLabel(label) {
        const step = OriginPathBuilder.STEPS.find(s => s.step === label);
        return step?.key || null;
    }

    /* -------------------------------------------- */
    /*  Context Preparation                         */
    /* -------------------------------------------- */

    /** @override */
    async _prepareContext(options) {
        const context = await super._prepareContext(options);

        // Prepare steps with current selections
        context.steps = await this._prepareSteps();

        // Calculate total bonuses from path
        context.preview = this._calculatePreview();

        // Determine if path is complete
        context.isComplete = Object.keys(this.selections).length === 6;

        // Check if path has changed from actor
        context.hasChanges = this._hasChanges();

        return context;
    }

    /**
     * Prepare step data for template
     * @returns {Promise<Array>}
     * @private
     */
    async _prepareSteps() {
        const steps = [];

        for (const stepConfig of OriginPathBuilder.STEPS) {
            const itemId = this.selections[stepConfig.key];
            const item = itemId ? (this.itemCache[stepConfig.key] || await this._fetchItem(itemId)) : null;

            steps.push({
                key: stepConfig.key,
                label: game.i18n.localize(stepConfig.label),
                step: stepConfig.step,
                icon: stepConfig.icon,
                item: item ? this._prepareItemData(item) : null,
                isEmpty: !item
            });
        }

        return steps;
    }

    /**
     * Fetch item from actor or compendium
     * @param {string} itemId - Item ID
     * @returns {Promise<object|null>}
     * @private
     */
    async _fetchItem(itemId) {
        // Try actor first
        let item = this.actor.items.get(itemId);
        
        // Try world items
        if (!item) {
            item = game.items.get(itemId);
        }
        
        // Try compendiums
        if (!item) {
            for (const pack of game.packs) {
                if (pack.metadata.type !== "Item") continue;
                item = await pack.getDocument(itemId);
                if (item) break;
            }
        }

        return item || null;
    }

    /**
     * Prepare item data for template
     * @param {object} item - Item document
     * @returns {object}
     * @private
     */
    _prepareItemData(item) {
        return {
            id: item.id,
            uuid: item.uuid,
            name: item.name,
            img: item.img,
            description: item.system?.description || "",
            bonuses: this._extractBonuses(item)
        };
    }

    /**
     * Extract bonuses from item
     * @param {object} item - Item document
     * @returns {Array<{type: string, value: string}>}
     * @private
     */
    _extractBonuses(item) {
        const bonuses = [];

        // Check for characteristic modifiers
        if (item.system?.modifiers?.characteristics) {
            for (const [char, value] of Object.entries(item.system.modifiers.characteristics)) {
                if (value !== 0) {
                    const label = CONFIG.rt.characteristics[char]?.abbreviation || char;
                    bonuses.push({
                        type: "characteristic",
                        label: label,
                        value: value > 0 ? `+${value}` : `${value}`
                    });
                }
            }
        }

        // Check for skill modifiers
        if (item.system?.modifiers?.skills) {
            for (const [skill, value] of Object.entries(item.system.modifiers.skills)) {
                if (value !== 0) {
                    bonuses.push({
                        type: "skill",
                        label: skill,
                        value: value > 0 ? `+${value}` : `${value}`
                    });
                }
            }
        }

        // Check for special abilities
        if (item.system?.abilities) {
            bonuses.push({
                type: "ability",
                label: "Special Abilities",
                value: item.system.abilities
            });
        }

        return bonuses;
    }

    /**
     * Calculate preview of total bonuses
     * @returns {object}
     * @private
     */
    _calculatePreview() {
        const preview = {
            characteristics: {},
            skills: {},
            abilities: []
        };

        // Sum up bonuses from all selected items
        for (const [stepKey, itemId] of Object.entries(this.selections)) {
            const item = this.itemCache[stepKey];
            if (!item) continue;

            // Characteristics
            if (item.system?.modifiers?.characteristics) {
                for (const [char, value] of Object.entries(item.system.modifiers.characteristics)) {
                    preview.characteristics[char] = (preview.characteristics[char] || 0) + value;
                }
            }

            // Skills
            if (item.system?.modifiers?.skills) {
                for (const [skill, value] of Object.entries(item.system.modifiers.skills)) {
                    preview.skills[skill] = (preview.skills[skill] || 0) + value;
                }
            }

            // Abilities
            if (item.system?.abilities) {
                preview.abilities.push({
                    source: item.name,
                    text: item.system.abilities
                });
            }
        }

        return preview;
    }

    /**
     * Check if current selections differ from actor's items
     * @returns {boolean}
     * @private
     */
    _hasChanges() {
        const actorOriginItems = this.actor.items.filter(i => i.isOriginPath);
        
        // Different count?
        if (Object.keys(this.selections).length !== actorOriginItems.length) {
            return true;
        }

        // Different items?
        for (const [stepKey, itemId] of Object.entries(this.selections)) {
            const stepLabel = OriginPathBuilder.STEPS.find(s => s.key === stepKey)?.step;
            const actorItem = actorOriginItems.find(i => i.originPathStep === stepLabel);
            
            if (!actorItem || actorItem.id !== itemId) {
                return true;
            }
        }

        return false;
    }

    /* -------------------------------------------- */
    /*  Drag & Drop                                 */
    /* -------------------------------------------- */

    /** @override */
    _onDragStart(event) {
        const slot = event.currentTarget;
        const stepKey = slot.dataset.step;
        const itemId = this.selections[stepKey];

        if (!itemId) return;

        const item = this.itemCache[stepKey];
        if (!item) return;

        event.dataTransfer.setData("text/plain", JSON.stringify({
            type: "Item",
            uuid: item.uuid
        }));
    }

    /** @override */
    async _onDrop(event) {
        event.preventDefault();
        
        const data = TextEditor.getDragEventData(event);
        if (data.type !== "Item") return;

        // Get dropped item
        const item = await fromUuid(data.uuid);
        if (!item || !item.isOriginPath) {
            ui.notifications.warn(game.i18n.localize("RT.OriginPath.InvalidItem"));
            return;
        }

        // Get target slot
        const slot = event.currentTarget;
        const targetStep = slot.dataset.step;

        // Validate item matches target step
        const itemStep = item.originPathStep;
        const targetStepLabel = OriginPathBuilder.STEPS.find(s => s.key === targetStep)?.step;

        if (itemStep !== targetStepLabel) {
            ui.notifications.warn(game.i18n.format("RT.OriginPath.WrongStep", {
                item: item.name,
                expected: targetStepLabel,
                actual: itemStep
            }));
            return;
        }

        // Set selection
        await this._setSelection(targetStep, item);
    }

    /**
     * Set selection for a step
     * @param {string} stepKey - Step key
     * @param {object} item - Item document
     * @private
     */
    async _setSelection(stepKey, item) {
        this.selections[stepKey] = item.id;
        this.itemCache[stepKey] = item;
        
        await this.render();
    }

    /* -------------------------------------------- */
    /*  Action Handlers                             */
    /* -------------------------------------------- */

    /**
     * Clear a step slot
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #clearSlot(event, target) {
        const stepKey = target.closest(".origin-step").dataset.step;
        
        delete this.selections[stepKey];
        delete this.itemCache[stepKey];
        
        await this.render();
    }

    /**
     * Randomize entire origin path
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #randomize(event, target) {
        const confirmed = await ConfirmationDialog.confirm({
            title: game.i18n.localize("RT.OriginPath.RandomizeTitle"),
            content: game.i18n.localize("RT.OriginPath.RandomizeConfirm"),
            confirmLabel: game.i18n.localize("RT.Confirm"),
            cancelLabel: game.i18n.localize("RT.Cancel")
        });

        if (!confirmed) return;

        // Get origin path compendium
        const packName = "rogue-trader.rt-items-origin-path";
        const pack = game.packs.get(packName);

        if (!pack) {
            ui.notifications.error(game.i18n.format("RT.OriginPath.CompendiumNotFound", { pack: packName }));
            return;
        }

        // Load all items
        const index = await pack.getIndex();

        // Randomize each step
        for (const stepConfig of OriginPathBuilder.STEPS) {
            const stepItems = index.filter(i => {
                return i.name?.includes(stepConfig.step) || i.system?.step === stepConfig.step;
            });

            if (stepItems.length > 0) {
                const randomItem = stepItems[Math.floor(Math.random() * stepItems.length)];
                const item = await pack.getDocument(randomItem._id);
                
                this.selections[stepConfig.key] = item.id;
                this.itemCache[stepConfig.key] = item;
            }
        }

        await this.render();
        ui.notifications.info(game.i18n.localize("RT.OriginPath.Randomized"));
    }

    /**
     * Reset all selections
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #reset(event, target) {
        const confirmed = await ConfirmationDialog.confirm({
            title: game.i18n.localize("RT.OriginPath.ResetTitle"),
            content: game.i18n.localize("RT.OriginPath.ResetConfirm"),
            confirmLabel: game.i18n.localize("RT.Confirm"),
            cancelLabel: game.i18n.localize("RT.Cancel")
        });

        if (!confirmed) return;

        this.selections = {};
        this.itemCache = {};
        
        await this.render();
        ui.notifications.info(game.i18n.localize("RT.OriginPath.Reset"));
    }

    /**
     * Export path as JSON
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #export(event, target) {
        const exportData = {
            version: 1,
            name: `${this.actor.name} Origin Path`,
            selections: {}
        };

        for (const [stepKey, itemId] of Object.entries(this.selections)) {
            const item = this.itemCache[stepKey];
            if (item) {
                exportData.selections[stepKey] = {
                    uuid: item.uuid,
                    name: item.name
                };
            }
        }

        const json = JSON.stringify(exportData, null, 2);
        const filename = `${this.actor.name.slugify()}-origin-path.json`;

        saveDataToFile(json, "application/json", filename);
        ui.notifications.info(game.i18n.localize("RT.OriginPath.Exported"));
    }

    /**
     * Import path from JSON
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #import(event, target) {
        // Create file input
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const importData = JSON.parse(event.target.result);

                    // Validate format
                    if (!importData.version || !importData.selections) {
                        throw new Error("Invalid format");
                    }

                    // Load items by UUID
                    for (const [stepKey, data] of Object.entries(importData.selections)) {
                        const item = await fromUuid(data.uuid);
                        if (item) {
                            this.selections[stepKey] = item.id;
                            this.itemCache[stepKey] = item;
                        }
                    }

                    await this.render();
                    ui.notifications.info(game.i18n.localize("RT.OriginPath.Imported"));

                } catch (error) {
                    ui.notifications.error(game.i18n.localize("RT.OriginPath.ImportFailed"));
                    console.error("Origin Path import error:", error);
                }
            };

            reader.readAsText(file);
        };

        input.click();
    }

    /**
     * Open origin path compendium filtered to step
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #openCompendium(event, target) {
        const stepKey = target.closest(".origin-step").dataset.step;
        const stepLabel = OriginPathBuilder.STEPS.find(s => s.key === stepKey)?.step;

        const packName = "rogue-trader.rt-items-origin-path";
        const pack = game.packs.get(packName);

        if (!pack) {
            ui.notifications.error(game.i18n.format("RT.OriginPath.CompendiumNotFound", { pack: packName }));
            return;
        }

        // Open compendium with filter
        await pack.render(true, { filter: stepLabel });
    }

    /**
     * View item details
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #viewItem(event, target) {
        const stepKey = target.closest(".origin-step").dataset.step;
        const item = this.itemCache[stepKey];

        if (item) {
            item.sheet.render(true);
        }
    }

    /**
     * Commit path to actor
     * @param {Event} event - Triggering event
     * @param {HTMLElement} target - Target element
     * @private
     */
    static async #commitPath(event, target) {
        if (Object.keys(this.selections).length === 0) {
            ui.notifications.warn(game.i18n.localize("RT.OriginPath.NoSelections"));
            return;
        }

        const confirmed = await ConfirmationDialog.confirm({
            title: game.i18n.localize("RT.OriginPath.CommitTitle"),
            content: game.i18n.localize("RT.OriginPath.CommitConfirm"),
            confirmLabel: game.i18n.localize("RT.Confirm"),
            cancelLabel: game.i18n.localize("RT.Cancel")
        });

        if (!confirmed) return;

        // Remove existing origin path items
        const existingIds = this.actor.items.filter(i => i.isOriginPath).map(i => i.id);
        if (existingIds.length > 0) {
            await this.actor.deleteEmbeddedDocuments("Item", existingIds);
        }

        // Add new items
        const itemsToAdd = [];
        for (const [stepKey, itemId] of Object.entries(this.selections)) {
            const item = this.itemCache[stepKey];
            if (item) {
                itemsToAdd.push(item.toObject());
            }
        }

        if (itemsToAdd.length > 0) {
            await this.actor.createEmbeddedDocuments("Item", itemsToAdd);
        }

        ui.notifications.info(game.i18n.format("RT.OriginPath.Committed", { count: itemsToAdd.length }));
        
        // Close builder
        this.close();
    }

    /**
     * Form submission handler
     * @param {Event} event - Form submit event
     * @param {HTMLFormElement} form - The form
     * @param {FormDataExtended} formData - Processed form data
     * @private
     */
    static async #onFormSubmit(event, form, formData) {
        // Prevent default, handled by commit button
        event.preventDefault();
    }

    /* -------------------------------------------- */
    /*  Static Helpers                              */
    /* -------------------------------------------- */

    /**
     * Show origin path builder for an actor
     * @param {Actor} actor - The character actor
     * @returns {OriginPathBuilder}
     */
    static show(actor) {
        const builder = new OriginPathBuilder(actor);
        builder.render(true);
        return builder;
    }

    /**
     * Close origin path builder for an actor
     * @param {Actor} actor - The character actor
     */
    static close(actor) {
        const existingBuilder = Object.values(ui.windows).find(
            w => w instanceof OriginPathBuilder && w.actor.id === actor.id
        );
        
        if (existingBuilder) {
            existingBuilder.close();
        }
    }

    /**
     * Toggle origin path builder for an actor
     * @param {Actor} actor - The character actor
     * @returns {OriginPathBuilder|null}
     */
    static toggle(actor) {
        const existingBuilder = Object.values(ui.windows).find(
            w => w instanceof OriginPathBuilder && w.actor.id === actor.id
        );

        if (existingBuilder) {
            existingBuilder.close();
            return null;
        } else {
            return OriginPathBuilder.show(actor);
        }
    }
}
